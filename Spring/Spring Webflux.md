# TIL: Spring WebFlux

## Spring WebFlux 개요

Spring WebFlux는 비동기적이고 논블로킹 방식으로 동작하는 리액티브 웹 프레임워크입니다. 고도의 동시성을 요구하는 시스템에서 효율적인 자원 사용과 높은 성능을 보장하며, 기존의 Spring MVC가 동기적 요청 처리 모델에 기반한 반면 WebFlux는 리액티브 프로그래밍 패러다임을 도입하여 더 나은 확장성과 성능을 제공합니다. 특히 마이크로서비스 아키텍처나 실시간 상호작용을 요구하는 웹 애플리케이션에서 중요한 이점을 제공합니다. WebFlux는 서버와 클라이언트 간의 효율적인 통신을 위해 설계되었으며, 자원 관리 측면에서도 매우 우수합니다.

## 주요 특징

1. **비동기 및 논블로킹 처리**
   - WebFlux는 요청을 비동기적으로 처리하며, I/O 작업 중 스레드가 블로킹되지 않도록 설계되어 있습니다. 이러한 설계는 자원 효율성을 극대화하며, 특히 높은 동시성을 요구하는 시스템에서 많은 요청을 동시에 처리할 수 있게 합니다. 이 구조는 시스템의 처리량을 극대화하고 응답 시간을 줄이며, 스레드가 특정 작업에 묶이지 않고 자유롭게 다른 작업을 수행할 수 있도록 합니다. 결과적으로 전체적인 성능과 응답성이 크게 향상됩니다.

2. **리액티브 스트림 지원**
   - WebFlux는 리액티브 스트림을 지원하며, `Publisher`와 `Subscriber` 개념을 사용해 데이터를 스트림 형태로 처리합니다. `Mono`와 `Flux`는 각각 단일 값과 다중 값을 비동기적으로 처리하는 리액티브 타입입니다. 리액티브 스트림 모델은 데이터의 흐름을 제어하고, 데이터가 준비되는 대로 이벤트 기반으로 처리하기 때문에 높은 유연성과 효율성을 제공합니다. 특히 데이터 흐름이 복잡하거나 여러 단계를 거치는 경우, 리액티브 프로그래밍은 복잡성을 줄이고 코드의 가독성을 높이는 데 기여합니다.

3. **Netty와 같은 논블로킹 런타임 지원**
   - 기본적으로 WebFlux는 `Netty`를 사용하지만, 서블릿 3.1+를 지원하는 서버(Tomcat, Jetty)에서도 동작할 수 있습니다. Netty는 고성능 네트워크 애플리케이션을 위한 프레임워크로, WebFlux와 결합하여 요청 및 응답을 효율적으로 처리할 수 있게 합니다. Netty의 이벤트 기반 아키텍처는 수많은 동시 요청을 효율적으로 처리하며, CPU와 메모리 자원을 최적으로 활용하는 데 기여합니다. 이러한 특성은 대규모 트래픽을 처리하는 시스템에서 성능 향상을 가져옵니다.

## WebFlux와 Spring MVC 비교

| 특징                | Spring MVC          | Spring WebFlux        |
|---------------------|---------------------|-----------------------|
| 처리 방식           | 동기/블로킹         | 비동기/논블로킹       |
| 프로그래밍 모델     | 애노테이션 기반     | 리액티브, 함수형      |
| 적합한 사용 사례    | 간단한 웹 애플리케이션 | 높은 동시성 요구 상황 |

Spring MVC는 요청이 처리될 때까지 스레드가 블로킹되므로 다른 작업을 처리하지 못하는 반면, WebFlux는 비동기 논블로킹 방식으로 설계되어 동시에 많은 요청을 효율적으로 처리합니다. WebFlux의 리액티브 프로그래밍 모델은 데이터가 준비될 때마다 해당 데이터를 처리하여 높은 응답성을 제공하고, 대규모 시스템에서 큰 장점을 제공합니다. 이는 특히 실시간 처리나 대규모 동시성 요구가 있는 애플리케이션에서 유용합니다.

## WebFlux 기본 설정

WebFlux를 사용하려면 `build.gradle` 파일에 필요한 의존성을 추가해야 합니다.

```kotlin
dependencies {
    implementation("org.springframework.boot:spring-boot-starter-webflux")
}
```

이 의존성을 추가함으로써 WebFlux의 비동기 기능과 리액티브 프로그래밍 모델을 활용할 수 있습니다. 이를 통해 애플리케이션은 더 많은 동시 요청을 처리하며, 전반적인 응답 시간을 줄일 수 있습니다. WebFlux는 비동기 처리를 요하는 시스템에서 특히 높은 성능을 발휘합니다.

아래는 간단한 RESTful 컨트롤러의 작성 예시입니다.

```kotlin
@RestController
class GreetingController {

    @GetMapping("/greet")
    fun greet(@RequestParam name: String): Mono<String> {
        return Mono.just("Hello, \$name!")
    }
}
```

이 예제는 `/greet` 경로로 들어오는 요청에 대해 `Mono` 타입을 사용하여 비동기적으로 응답합니다. `Mono`는 단일 값을 비동기적으로 반환하는 데 사용되며, 이를 통해 클라이언트는 서버의 응답을 기다리는 동안 다른 작업을 수행할 수 있습니다. 이러한 방식은 시스템 전반의 응답성을 크게 향상시키며, 비동기 작업이 많이 필요한 환경에서 유리합니다.

## WebSocket을 통한 실시간 통신

Spring WebFlux는 WebSocket과 결합하여 실시간 통신 기능을 제공합니다. WebSocket은 서버와 클라이언트 간의 양방향 통신을 지원하며, 실시간 데이터 전송을 가능하게 하는 프로토콜입니다. 이를 통해 채팅 애플리케이션, 실시간 알림 시스템, 게임 등 다양한 실시간 애플리케이션에서 활용할 수 있습니다.

아래는 WebSocket 핸들러 작성 예시입니다.

```kotlin
@Component
class GreetingWebSocketHandler : WebSocketHandler {
    override fun handle(session: WebSocketSession): Mono<Void> {
        return session.send(
            session.receive()
                .map { msg -> session.textMessage("Hello, \${msg.payloadAsText}!") }
        )
    }
}
```

이 예제는 클라이언트가 메시지를 전송하면 서버가 해당 메시지에 응답하는 방식으로 WebSocket 통신을 구현합니다. WebSocket은 지속적인 연결을 유지하기 때문에 실시간으로 데이터를 주고받는 데 매우 효율적입니다. WebFlux의 비동기 처리 특성 덕분에 많은 클라이언트와의 WebSocket 연결을 동시에 유지하면서 높은 성능을 제공합니다. 이러한 특성은 실시간 상호작용이 중요한 애플리케이션에서 중요한 이점을 제공합니다.

## WebFlux의 장점

- **고성능**: 비동기 논블로킹 처리 덕분에 높은 처리량을 제공하며, 대규모 트래픽 상황에서도 안정적으로 작동합니다. 이는 서버 자원의 효율적 사용을 통해 대규모 애플리케이션에서 요구되는 성능을 충족시킵니다.
- **리소스 효율성**: 블로킹을 피하고 스레드 풀이 과도하게 커지는 것을 방지함으로써 서버 리소스를 효율적으로 사용할 수 있습니다. 이는 비용 절감과 동시에 더 나은 성능을 제공하는 데 기여합니다.
- **리액티브 프로그래밍**: `Mono`와 `Flux` 같은 리액티브 타입을 사용해 데이터를 스트림 형태로 처리하며, 이벤트 기반 아키텍처 구현이 용이합니다. 이는 비동기 데이터 흐름을 효율적으로 관리하고, 코드의 유지보수성을 높이는 데 중요한 역할을 합니다.
- **확장성**: 비동기 처리와 리액티브 프로그래밍 덕분에 WebFlux는 높은 확장성을 제공합니다. 애플리케이션의 트래픽이 증가할 때, 추가적인 하드웨어 자원을 효율적으로 사용할 수 있어 시스템을 쉽게 확장할 수 있습니다.

## 결론

Spring WebFlux는 비동기 및 논블로킹 방식으로 현대적인 웹 애플리케이션을 구축하기에 적합한 프레임워크입니다. 리액티브 프로그래밍 모델을 도입함으로써 높은 동시성을 효율적으로 처리할 수 있으며, 특히 마이크로서비스 아키텍처나 대기 시간이 중요한 애플리케이션에 적합합니다. WebFlux는 서버 자원의 효율적 관리와 실시간 통신의 용이성을 제공함으로써, 사용자 경험을 향상시키고 시스템의 성능을 극대화할 수 있는 강력한 도구입니다. 이를 통해 개발자는 더 나은 사용자 경험과 성능을 제공하는 동시에, 시스템의 확장성을 확보할 수 있습니다.